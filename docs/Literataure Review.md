# Literature Review
To demonstrate the increasing complexity of programming languages, consider the C++ programming language. In the early days of C++, the language was a relatively modest improvement on the C language; in fact, it is often dubbed "C with classes." It included classes, default arguments, operator overloading, new and delete operators, and the const modifier (History of C++). As software requirements evolved, so did software complexity. As such, the demand for reusable libraries helped to direct C++ to introduce generic programming capabilities. Templates were introduced some years later, in 1990, which allowed for programmers to statically parameterize functions and data structures with a set of types. Earlier, a generic array might simply have been an array of void pointers or discriminated unions describing all the possible types the program needed to support. With the introduction of templates, an array class can be parameterized by the type of its values, which allows for the otherwise previously unsafe generic array access to be made typesafe. Additionally, as the type of the container is always knowable with the introduction of templates, compilers can enact more granular optimizations, specific to each container instantiation. As the complexity of the C++ type system grew, ergonomics suffered. So in C++11, the auto keyword was repurposed to be a placeholder in which the compiler would deduce the type (Placeholder Type Specifiers). This allowed declarations such as std::map<KeyType, ValueType>::iterator it = map.begin() to be rewritten as auto it = map.begin(). It also allows for generalized iteration, provided the container meets the iteration specification (in general, this means it has a begin() method, an end() method, and the returned iterator can be incremented and almost always dereferenced). C++ is not the only language to provide such a feature: Java now has the var keyword which operates similarly, and both TypeScript and Rust implicitly infer the types of variables where possible, with support for optional explicit typing. MattyLang, in contrast, will implicitly infer the types of variables but will not have support for explicitly typing for variables, as all variables must be initialized at the point of their declaration. This constraint may change in the future.

# References
- History of C++. cppreference.com. Retrieved August 15, 2022, from https://en.cppreference.com/w/cpp/language/history
- Placeholder Type Specifiers. cppreference.com. Retrieved August 15, 2022, from https://en.cppreference.com/w/cpp/language/auto
